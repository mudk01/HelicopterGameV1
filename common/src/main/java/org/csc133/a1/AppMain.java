package org.csc133.a1;

import com.codename1.charts.util.ColorUtil;
import com.codename1.system.Lifecycle;
import com.codename1.ui.*;
import com.codename1.ui.geom.Point;
import com.codename1.ui.util.UITimer;
import sun.tools.asm.SwitchData;

import java.util.ArrayList;
import java.util.Random;

/**
 * This file was generated by <a href="https://www.codenameone.com/">Codename One</a> for the purpose
 * of building native mobile applications using Java.
 */
public class AppMain extends Lifecycle {
    @Override
    public void runApp() {
        new Game().show();
    }


}

class Game extends Form implements Runnable {
    private GameWorld gw;

    final static int DISP_W = Display.getInstance().getDisplayWidth();
    final static int DISP_H = Display.getInstance().getDisplayHeight();
//
//    public static int getSmallDim() { return Math.min(DISP_W,DISP_H); }
//    public static int getLargeDim() { return Math.max(DISP_W,DISP_H); }

    public Game() {
        gw = new GameWorld();

        addKeyListener('Q', (evt) -> gw.quit());
        addKeyListener(-92, (evt) -> gw.input(-92));
        addKeyListener(-91, (evt) -> gw.input(-91));
        addKeyListener(-94, (evt) -> gw.input(-94));
        addKeyListener(-93, (evt) -> gw.input(-93));
        addKeyListener('d', (evt) -> gw.input('d'));
        addKeyListener('f', (evt) -> gw.input('f'));


        UITimer timer = new UITimer(this);
        timer.schedule(50, true, this);

        this.getAllStyles().setBgColor(ColorUtil.BLACK);
        this.show();
    }

     public void paint(Graphics g) {
        super.paint(g);
        gw.draw(g);
    }

    @Override
    public void run() {
        gw.tick();
        repaint();
    }

}

class GameWorld {
    private River river;
    private Helipad helipad;
    private Fire fire1, fire2, fire3;
    private ArrayList<Fire> fires, deadFires;
    private Helicopter helicopter;
    private int fireSize1, fireSize2, fireSize3;
    private Point fireLocation1, fireLocation2, fireLocaton3;
    private int fuel, tickCount;

    public GameWorld() {
        init();
    }

    private void init() {
        river = new River();
        helipad = new Helipad();
        fireSize1 = new Random().nextInt(100) +
                Game.DISP_H/10;
        fireSize2 = new Random().nextInt(100) +
                Game.DISP_H/8;
        fireSize3 = new Random().nextInt(100) +
                Game.DISP_H/5;
        fireLocation1 = new Point(new Random().nextInt(80) +
                (int)(Game.DISP_W/4.5),
                new Random().nextInt(50) +
                Game.DISP_H/3 -
                (int)(Game.DISP_H/3.5));
        fireLocation2 = new Point(new Random().nextInt(80) +
                Game.DISP_W/2,
                new Random().nextInt(80) +
                Game.DISP_H/2);
        fireLocaton3 = new Point(new Random().nextInt(50) +
                Game.DISP_W -
                (int)(fireSize3*1.5), new Random().nextInt(80) +
                Game.DISP_H/3 -
                (int)(Game.DISP_H/3.5));
        fire1 = new Fire(fireSize1, fireLocation1);
        fire2 = new Fire(fireSize2, fireLocation2);
        fire3 = new Fire(fireSize3, fireLocaton3);
        fires = new ArrayList<>();
        deadFires = new ArrayList<>();
        fires.add(fire1);
        fires.add(fire2);
        fires.add(fire3);
        helicopter = new Helicopter(helipad.getHelipadCenter(), helipad.getHelipadSize());
        fuel = 30000;
        helicopter.setFuel(fuel);
        tickCount = 0;
    }

    void draw(Graphics g) {
        helipad.draw(g);
        for(Fire fire : fires) {
            fire.draw(g);
        }
        river.draw(g);
        helicopter.draw(g);
    }

    public void tick() {
        for(Fire fire : fires) {
            if(tickCount%10==0) {
                fire.growFire();
            }
            tickCount++;
            if(helicopter.checkFireCollision(fire)) {
                fire.setTue();
            } else {
                fire.setFalse();
            }
            if(fire.getSize() <= 0) {
                deadFires.add(fire);
            }
        }
//        for(Fire deadFire: fires) {
//            if(deadFire.getSize() <= 0) {
//                deadFire.removeFire();
//                fires.remove(deadFire);
//            }
//        }
        fires.removeAll(deadFires);
        if(fires.isEmpty() && helicopter.isOnPad()) {
            gameWon();
        }
        helicopter.move();
        helicopter.checkRiverCollision(river.getLocation(), river.getWidth(),
                river.getHeight());
        if(helicopter.checkFuel()) {
            endGame();
        }

    }

    public void input(int input) {
        switch (input) {
            case -92:
                helicopter.moveBackwards();
                break;
            case -91:
                helicopter.moveForwards();
                break;
            case -93:
                helicopter.moveLeft();
                break;
            case -94:
                helicopter.moveRight();
                break;
            case 'd':
                helicopter.drinkWater();
                break;
            case 'f':
                helicopter.fightFire(fires);
                helicopter.dropWater();
                break;
        }
    }

    public void quit() {
        if(Dialog.show("Confirm", "Do you want to Quit?", "OK",
                "Cancel")) {
            Display.getInstance().exitApplication();
        }
    }

    public void endGame() {
        if(Dialog.show("Game Over", "You ran out of fuel",
                "Replay", "Exit")) {
            init();
            }
            else {
                Display.getInstance().exitApplication();
            }
    }

    public void gameWon() {
        if(Dialog.show("Congratulations!", "You put out all the fires!",
                "Replay", "Exit")) {
            init();
        }
        else {
            Display.getInstance().exitApplication();
        }
    }
}

class River {
    private Point location;
    private int width;
    private int height;

    public River() {
        width = Game.DISP_W-4;
        height = Game.DISP_H/8;
        location = new Point(0, Game.DISP_H/3 - height);

    }

    public Point getLocation() {
        return location;
    }

    public int getWidth() {
        return width;
    }

    public int getHeight() {
        return height;
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.BLUE);
        g.drawRect(location.getX(),location.getY(), width, height);
    }
}

class Helipad {
    private Point rectangleLocation, centerLocation;
    private int boxSize;
    private int circleSize, radius;

    public Helipad() {
        boxSize = 150;
        circleSize = 100;
        radius = circleSize/2;
        rectangleLocation = new Point(Game.DISP_W/2 - boxSize/2,
                (int) (Game.DISP_H - (boxSize*1.5)));
        centerLocation =
                new Point(rectangleLocation.getX() + (boxSize/2),
                        rectangleLocation.getY() + (boxSize/2));
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.GRAY);
        g.drawRect(rectangleLocation.getX(), rectangleLocation.getY(), boxSize,
                boxSize, 5);
        g.drawArc(centerLocation.getX() - radius,
                centerLocation.getY() - radius, circleSize,
                circleSize, 0, 360);
        g.setColor(ColorUtil.BLUE);
    }

    public Point getHelipadCenter() {
        return centerLocation;
    }

    public int getHelipadSize() {
        return circleSize;
    }


}

class Fire {
    private Point centerLocation;
    private int size, radius;
    private Font fireSizeFont;
    private boolean isDetected;

    public Fire(int fireSize, Point fireLocation) {
        size = fireSize;
        radius = fireSize/2;
        centerLocation = new Point(fireLocation.getX() + radius,
                fireLocation.getY() + radius);
        fireSizeFont = Font.createSystemFont(Font.FACE_SYSTEM,
                Font.STYLE_PLAIN, Font.SIZE_MEDIUM);
        isDetected = false;
    }

    public void setTue() {
        isDetected = true;
    }
    public void setFalse() {
        isDetected = false;
    }

    public boolean detected() {
        return isDetected;
    }

    void growFire() {
        int move = new Random().nextInt(2);
        size += move;
        radius = size/2;
        centerLocation.setX(centerLocation.getX() - (int)(move/2));
        centerLocation.setY(centerLocation.getY() - (int)(move/2));
    }

    public Point getFireLocation() {
        return centerLocation;
    }

    public int getRadius() {
        return radius;
    }

    public int getSize() {
        return size;
    }

    void reduceFire(int water) {
        size -= water / (new Random().nextInt(7) + 8);
    }


    void draw(Graphics g) {
        g.setColor(ColorUtil.MAGENTA);
        g.setFont(fireSizeFont);

        if(size>0) {
            g.fillArc(centerLocation.getX() - radius,
                    centerLocation.getY() - radius, size, size,0,
                    360);
            g.drawString("" + size, centerLocation.getX() + radius,
                    centerLocation.getY() + radius);
        }
    }

}

class Helicopter {
    private int size, hRadius, centerX, centerY, currSpeed, fuel, water;
    private Point helipadCenterLocation, heliLocation;
    private int endHeadX, endHeadY, padSize;
    private double angle;
    private final int MAX_SPEED = 10;
    private boolean riverCollision;

    public Helicopter(Point heliCenter, int helipadSize) {
        size = 30;
        currSpeed = 0;
        fuel = 0;
        water = 0;
        helipadCenterLocation = heliCenter;
        hRadius = size/2;
        heliLocation = new Point(helipadCenterLocation.getX() - hRadius,
                helipadCenterLocation.getY());
        centerX = heliLocation.getX() + hRadius;
        centerY = heliLocation.getY() + hRadius;

        angle = Math.toRadians(90);
        endHeadX = centerX;
        endHeadY = centerY - (size*2);
        riverCollision = false;
        padSize = helipadSize;
    }

    void move(){
        heliLocation.setY((int) (heliLocation.getY() - Math.sin(angle) * currSpeed));
        centerY = heliLocation.getY() + hRadius;
        heliLocation.setX((int) (heliLocation.getX() + Math.cos(angle) * currSpeed));
        centerX = heliLocation.getX() + hRadius;
        endHeadX = (int) (centerX + Math.cos(angle) * size*2);
        endHeadY = (int) (centerY - Math.sin(angle) * size*2);
        fuel -= 15;
    }

    void moveForwards() {
        if(currSpeed < MAX_SPEED) {
            currSpeed++;
        }
    }

    void moveBackwards() {
        if(currSpeed > 0) {
            currSpeed--;
        }
    }

    void moveLeft() {
        angle += Math.toRadians(15);
        endHeadX = (int) (centerX + Math.cos(angle) * size*2);
        endHeadY = (int) (centerY - Math.sin(angle) * size*2);
    }

    void moveRight() {
        angle -= Math.toRadians(15);
        endHeadX = (int) (centerX + Math.cos(angle) * size*2);
        endHeadY = (int) (centerY - Math.sin(angle) * size*2);
    }

    void checkRiverCollision(Point location, int width, int height) {
        riverCollision = (centerX >= location.getX() && centerY >= location.getY()) &&
                (centerX <= (location.getX() + width) && centerY <=
                        (location.getY() + height));
    }
    boolean checkFireCollision(Fire fire) {
        return (centerX >= (fire.getFireLocation().getX() - fire.getRadius()) &&
                centerY >= (fire.getFireLocation().getY() - fire.getRadius()))
                && (centerX <= (fire.getFireLocation().getX() +
                fire.getRadius()) && centerY <= (fire.getFireLocation().getY()
                + fire.getRadius()));
    }

    void drinkWater() {
        if((riverCollision && currSpeed <= 2) && water < 1000) {
                water += 100;
        }
    }

    void fightFire(ArrayList<Fire> fires) {
        for(Fire fire : fires) {
            if(fire.detected()) {
                fire.reduceFire(water);
            }
            fire.setFalse();
        }
    }

    void dropWater() {
        water = 0;
    }

    void setFuel(int fuelIn) {
        fuel = fuelIn;
    }

    public boolean checkFuel() {
        return fuel <= 0;
    }

    public boolean isOnPad() {
        return (centerX >= (helipadCenterLocation.getX() - padSize) &&
                centerY >= (helipadCenterLocation.getY() - padSize))
                && (centerX <= (helipadCenterLocation.getX() +
                padSize) && centerY <= (helipadCenterLocation.getY()
                + padSize));
    }

    void draw(Graphics g) {
        g.setColor(ColorUtil.YELLOW);
        g.fillArc(heliLocation.getX(),
                heliLocation.getY(), size,
                size, 0, 360);
        g.drawLine(centerX, centerY, endHeadX,
                endHeadY);
        g.drawString("F: " + fuel, heliLocation.getX(),
                heliLocation.getY() + (size*3));
        g.drawString("W: " + water ,heliLocation.getX(),
                heliLocation.getY() + (size*4));
    }
}